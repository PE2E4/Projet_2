# -*- coding: utf-8 -*-
"""FINAL ML Projet 2 Kung Fu Pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1piaf0oKGxf4Y3JJQB3hLMrFXaZIt6fvF

# **ETAPE 1 : IMPORTS**
"""

from google.colab import  drive
drive.mount('/drive')

import pandas as pd
pd.options.mode.chained_assignment = None
from ast import literal_eval

from sklearn.preprocessing import StandardScaler

from sklearn.neighbors import NearestNeighbors

from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import OrdinalEncoder
from sklearn.preprocessing import MultiLabelBinarizer

"""# **ETAPE 2 : MISE EN PETITES BRIQUES**"""

### Import et préparation des films
# Mange : rien
# Retourne : un DF de tous les films provenant du csv, propre avec bons types
def import_prep_dffilms():
    DF_films = pd.read_csv("/drive/My Drive/Projet 2/df_pandas.csv")
    ##création des colonnes minuscules pour original et primary title:
    DF_films=DF_films.assign(originaltitlemin=DF_films['originalTitle'].str.lower(),primarytitlemin=DF_films['primaryTitle'].str.lower())
    ##changer les actor et actress en liste:
    DF_films['actor']=DF_films['actor'].apply(literal_eval)
    DF_films['actress']=DF_films['actress'].apply(literal_eval)
    ##pour eviter qu'il compte les sans objet comme valeur:
    DF_films['actor'] = DF_films['actor'].apply(lambda x: ''  if x == ['sans objet'] else x)
    DF_films['actress'] = DF_films['actress'].apply(lambda x: ''  if x == ['sans objet'] else x)
    ##création des 5 colonnes:
    DF_films=DF_films.assign(nb_actor=DF_films['actor'].apply(lambda x: len(x)),nb_actress=DF_films['actress'].apply(lambda x: len(x)))
    #création colonne 'nb_films_director'
    DF_films['nb_films_director'] = DF_films.groupby('director')['director'].transform('count')
    ##changer les "" en 0:
    DF_films['nb_actor'] = DF_films['nb_actor'].apply(lambda x: 0  if x == "" else x)
    DF_films['nb_actress'] = DF_films['nb_actress'].apply(lambda x: 0  if x == "" else x)
    DF_films=DF_films.assign(total_acteurs=DF_films['nb_actor']+DF_films['nb_actress'])
    DF_films=DF_films.assign(pourc_actor=(DF_films['nb_actor']/DF_films['total_acteurs'])*100,pourc_actress=(DF_films['nb_actress']/DF_films['total_acteurs'])*100)
    DF_films['pourc_actress'].fillna(0,inplace=True)
    DF_films['pourc_actor'].fillna(0,inplace=True)
    #créer une colonne 'Films_WW' pour filtrer les films diffusés dans toutes les régions (valeur 1 ou 0)
    DF_films['films_WW']=0
    for i in range(len(DF_films)):
        if "XWW" in DF_films['region'][i]:
            DF_films['films_WW'][i]=1
    ##changer la colonne genre en list:
    DF_films['genres']=DF_films['genres'].apply(lambda x: list(x.split(',')))
    OHencod = OneHotEncoder(sparse=False)
    # je fais un OneHotEncoder avec mes liste dans genres
    mlb = MultiLabelBinarizer()
    df_genres_encod = pd.DataFrame(mlb.fit_transform(DF_films['genres']),columns=mlb.classes_, index=DF_films.index)
    # on concatène avec notre df_final précédent
    DF_films = pd.concat([DF_films, df_genres_encod], axis=1)

    return DF_films

DF_films_test = import_prep_dffilms()
DF_films_test

### Rechercher la ligne d’un film en particulier
# Mange : une chaine de caractère qui est le nom du film + un DF de tous les films
# Retourne : les valeurs de la ligne du film concerné
def recherche_ligne1film(nomfilmrecherche, DF_films):
        nomfilmrecherche=nomfilmrecherche.lower()
        cond=DF_films["primarytitlemin"].str.contains(nomfilmrecherche)
        cond1=DF_films["originaltitlemin"].str.contains(nomfilmrecherche)  
        ligne_1film = DF_films[cond|cond1]
        while len(ligne_1film)==0:
              ligne_1film=input('Film non trouvé. Veuillez saisir un nouveau titre de film :')
              ligne_1film=ligne_1film.lower()
              cond=DF_films["primarytitlemin"].str.contains(ligne_1film)
              cond1=DF_films["originaltitlemin"].str.contains(ligne_1film)  
              ligne_1film = DF_films[cond|cond1]
        if len(ligne_1film)==1:
              return ligne_1film
        else:
            ligne_1film=ligne_1film.reset_index()
            pd.set_option('display.max_rows', None)
            display(ligne_1film[['primaryTitle','originalTitle','startYear']])
            index=int(input('Précisez un numéro de ligne de film parmi la liste :'))
            while index not in range(len(ligne_1film)):
                  print('choissisez un numéro entre 0 et ',len(ligne_1film)-1,':')
                  index=int(input())
            ligne_1film=pd.DataFrame(ligne_1film.iloc[index]).T
            return ligne_1film

print('Pour une utilisation optimale de notre application,')
print('nous vous recommandons de choisir un film dont la durée est comprise entre 50 et 200 minutes')
print('et qui a au moins un des genres suivants : horror, crime, thriller, film-noir.')
nomfilmrecherche=input('Veuillez entrer un titre de film :')
ligne_1film_test = recherche_ligne1film(nomfilmrecherche, DF_films_test)
ligne_1film_test

### Préparation entrainement du modèle
# Mange : un DF avec tous les films
# Retourne : un scaler entrainé + un modèle entrainé
def prep_model(DF_films):
    ### récup des données quanti
    X = DF_films.select_dtypes('number')
    
    ### standardisation des données
    ### init
    scaler_films = StandardScaler()
    ### entrainer
    scaler_films.fit(X)
    ### appliquer
    X_scaled = scaler_films.transform(X)
    X_scaled = pd.DataFrame(X_scaled, index=X.index, columns=X.columns)
    X_scaled

    ### entrainement du modèle
    ### instancier modele
    model_films = NearestNeighbors()
    ### entrainer modele
    model_films.fit(X_scaled)
    return scaler_films, model_films

scaler_films_pretalemploi, model_films_pretalemploi = prep_model(DF_films_test)
scaler_films_pretalemploi, model_films_pretalemploi

### Trouver les plus proches voisins d’un film en particulier
# Mange : la ligne d’un film + un DF de tous les films + scaler entrainé + modèle entrainé
# Afficher : les films qui ressemblent le plus
def filmslesplusproches(ligne_1film, DF_films, scaler_films, model_films):
    ### scaler la ligne du film
    ligne_1film_scaled = scaler_films.transform(ligne_1film[scaler_films.feature_names_in_])
    ligne_1film_scaled = pd.DataFrame(ligne_1film_scaled, index=ligne_1film.index, columns=scaler_films.feature_names_in_) # ligne optionnelle
    ### les voisins
    neigh_dist, neigh_films =  model_films.kneighbors(ligne_1film_scaled)
    filmsproches = DF_films[['primaryTitle','originalTitle','startYear','genres','region','director','actor','actress','runtimeMinutes']].iloc[neigh_films[0]]
    pd.set_option('display.max_rows', None)
    return filmsproches

ligne_1film_test[scaler_films_pretalemploi.feature_names_in_]

filmslesplusproches(ligne_1film_test, DF_films_test, scaler_films_pretalemploi, model_films_pretalemploi)

"""# **ETAPE 3 : MISE EN PLACE DE L ALGO**

# 1. En amont

### fonction qui importe et prépare les films
### fonction qui prépare le modèle
"""

### import et préparation
DF_films_test = import_prep_dffilms()
DF_films_test

### préparer modèle
scaler_films_pretalemploi, model_films_pretalemploi = prep_model(DF_films_test)
scaler_films_pretalemploi, model_films_pretalemploi

### EXPORTER SCALER ET MODELE

"""# 2. Sur le moment

### fonction qui importe et prépare les films
### fonction qui recherche la ligne d'un film
### fonction qui va chercher les plus proches voisins
"""

### import et préparation
DF_films_test = import_prep_dffilms()
DF_films_test

### rechercher la ligne d'un film
print('Pour une utilisation optimale de notre application,')
print('nous vous recommandons de choisir un film dont la durée est comprise entre 50 et 200 minutes')
print('et qui a au moins un des genres suivants : horror, crime, thriller, film-noir.')
nomfilmrecherche=input('Veuillez entrer un titre de film :')
ligne_1film_test = recherche_ligne1film(nomfilmrecherche, DF_films_test)
ligne_1film_test

### chercher les plus proches voisins
# scaler_films_pretalemploi, model_films_pretalemploi : A IMPORTER
filmslesplusproches(ligne_1film_test, DF_films_test, scaler_films_pretalemploi, model_films_pretalemploi)

"""# Sur le moment

## caché
"""

DF_films_test = import_prep_dffilms()

def reco_films():
    print('Pour une utilisation optimale de notre application,')
    print('nous vous recommandons de choisir un film dont la durée est comprise entre 50 et 200 minutes')
    print('et qui a au moins un des genres suivants : horror, crime, thriller, film-noir.')
    nomfilmrecherche=input('Veuillez entrer un titre de film :')
    ligne_1film_test = recherche_ligne1film(nomfilmrecherche, DF_films_test) # ici DF_films_test est pas dans la fonction mais il va aller le chercher dans le global
    return filmslesplusproches(ligne_1film_test, DF_films_test, scaler_films_pretalemploi, model_films_pretalemploi)

"""## visible"""

reco_films()